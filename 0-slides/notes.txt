Motivation
==========

Thought experiment. We want to be able to:

 - write clean, maintainable code;
 - bind web addresses to pieces of code in our web application;
 - retrieve data from the URLs in a type-safe fashion;
 - generate new URLs within our application;
 - bolt on request-processing functionality as required;
 - compose routes together to produce other routes. (???)

And we want to do it in an elegant way.

 - simple, clean syntax;
 - type safety.

See it in action
================

Show a demo web app - calculator.

Show the routing table.

Possible running example, "/add/NUMBER/to/NUMBER", demonstrates:
 - typed arguments (part 1)
 - discarding path segments (part 2)

Build it!
=========

Walk through the essential components of the demo:

 - HLists
   - Data definition of List
   - Type definition of HList
   - Very high-level comparison:
     - Types in List are recursive; types in HList are not
     - Difference in definition of cons
   - Pointers to blog posts and discussion

 - Simple path example
   - Assume we want *everything* from the URL
   - Demonstrate decoding and encoding URLs
     - Introduce Bidi function to parse one path part
   - Introduce Path
     - Definitions of encode() and decode()
   - Introduce PCons and PNil
   - Implement "/" method on most concrete types (i.e. PCons and PNil)
     to make sure compiler infers correct return types
 
 - Realistic path example
   - Want to decouple path length from argument list length
     - Introduce LiteralArg to capture constant parts of the URL
     - Introduce PLiteral and PMatch subclasses of PCons
   - Want rest-style arguments
     - Swap "/" for ":/:" to make it right-associative
     - As we're building the Path from right to left, we can have PAny as well as PNil
   - Move definitions of ":/:" from PCons to PLiteral and PMatch
     to make sure compiler infers correct return types...
     include example error message perhaps?

          scala> (PNil / StringArg).encode(HCons("abc", HNil))
          res4: List[java.lang.String] = List(abc)

          scala> (PNil / StringArg / StringArg).encode(HCons("abc", HCons("def", HNil)))
          <console>:8: error: type mismatch;
           found   : HCons[java.lang.String,HNil.type]
           required: _4.tail.Result where val _4: PMatch[String,PCons[String,PNil]]
                        (PNil / StringArg / StringArg).encode(HCons("abc", HCons("def", HNil)))

 - Simple site example
   - Introduce Route to bind paths to functions
   - Introduce Site to collect routes into a single dispatch function
   - Add a ">>" method to PLiteral, PMatch, PNil and PAny that combines the Path with a function and a Site to produce a route
     - Use implicit arguments to pass in a reference to the Site, so the route can register itself
   - Problems:
     - HLists are a pain to destructure
     - the arguments to the route functions are all HLists
     - the arguments to the url() and apply() methods are also HLists
 
 - Simple implicits example
   - Convert conventional FunctionN objects to HList functions
     - Use implicit conversions so we can pass FunctionN objects to >>()
   - Attempt to simplify url() and apply() by converting Tuples to HLists. Problems:
     - there's no Tuple0 ... Unit partially suffices;
     - Tuple1 is a pain to write;
     - you need to import the HListOps implicits wherever you call the methods
 
 - Better implicits example:
   - Rather than change the the arguments to the methods on Route, change the methods themselves
     - Add RouteN subclasses of Route
       - Accept FunctionN objects as constructor arguments, and wrap them as appropriate
       - Have url() and apply() methods with the right number of arguments
     - Use implicit conversions to "pimp" Paths of various arities to add a >>() method with the right return type
     - Use implicit argument lists to add the reference to the site in at the last minute
     - Define the path pimping functionality in a separate trait called RouteBuilder and mix it into Site
       - Define a few arities by default to suit most peoples' needs
       - Users can easily add more by subclassing RouteBuilder
       - Potential to add another set of pimps (e.g. >>> function) to get URLs with rest arguments
 
 - Routes (binding paths to code)
   - HList <-> Tuple conversion
   - HList <-> argument list conversion

Extensions
==========

Where can we take this next? Bit of an open discussion:

 - Dispatch to templates
 - Rest arguments ??
 - Type-safe URL parameter parsing ??
 - Other data from the request ??

? Related work
==============

Run through these libraries:

 - Sinatra/Scalatra/Django
 - Unfiltered,Blueeyes
 - Dispatch.plt
 - Lift SiteMap

and comment on:

 - type safety;
 - bi-directionality;
 - composability.
